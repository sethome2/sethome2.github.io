<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" >

<title>背包DP问题+动态规划 保姆级教程 包教包会 | sethome的橱窗</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://sethome2.github.io/favicon.ico?v=1649960047276">
<link rel="stylesheet" href="https://sethome2.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-GGN093XZS4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GGN093XZS4');
</script>
<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?962ffd213ed43ff588cf9a794c723d58";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>
<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-P786JZL');
</script>
<!-- End Google Tag Manager -->
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-GGN093XZS4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-GGN093XZS4');
</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css" integrity="sha384-KiWOvVjnN8qwAZbuQyWDIbfCLFhLXNETzBQjA/92pIowpC0d2O3nppDGQVgwd2nB" crossorigin="anonymous">
<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js" integrity="sha384-0fdwu/T/EQMsQlrHCCHoH10pkPLlKA1jL5dFyUOvB3lfeT2540/2g6YgSi2BL14p" crossorigin="anonymous"></script>
<!-- To automatically render math in text elements, include the auto-render extension: -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>



    <meta name="description" content="嘶，突然想起来，高中的时候其实没有认真学过DP（动态规划）的，记忆化搜索和DP只能说是异曲同工之妙，真正的DP核心在于状态转移方程。
之前遇到DP问题，都是直接恩算，尝试找出二维网格里面的一些关系。今天想了想，是应该从背包DP——这最简单的..." />
    <meta name="keywords" content="algorithm,technique,中文" />
</head>

<body>
  <!-- Google Tag Manager (noscript) -->
  <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-P786JZL"
  height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
  <!-- End Google Tag Manager (noscript) -->
  
  <div id="app" class="main">

    <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://sethome2.github.io">
        <img src="https://sethome2.github.io/images/avatar.png?v=1649960047276" class="site-logo">
        <h1 class="site-title">sethome的橱窗</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="https://sethome2.github.io" class="site-nav">
            首页 / Home
          </a>
        
      
        
          <a href="https://sethome2.github.io/tag/VvCd9lSL-/" class="site-nav">
            奇怪的项目 / Project
          </a>
        
      
        
          <a href="https://sethome2.github.io/tag/T7U4S5FR5/" class="site-nav">
            照片 / Picture
          </a>
        
      
        
          <a href="https://sethome2.github.io/tags" class="site-nav">
            文章标签 / Article Tags
          </a>
        
      
        
          <a href="https://sethome2.github.io/archives" class="site-nav">
            文章列表 / Article List
          </a>
        
      
        
          <a href="https://sethome2.github.io/post/about" class="site-nav">
            关于 / About
          </a>
        
      
        
          <a href="https://sethome2.github.io/post/you-qing-lian-jie" class="site-nav" target="_blank">
            友情链接 / ExchangeLink
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/sethome2" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      sethome的橱窗
    </div>
    <div class="site-footer">
      <p>除另有声明外，图片不得商用，商业电邮</p>
<p>文章转载与引用请附上链接</p>
Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea
<div target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=45012202000129" style="color:#dee2e6;">桂公网安备 45012202000129号<p></p></div>
<a href="http://www.beian.miit.gov.cn/" style="color:#dee2e6;"> 桂ICP备2022001235号-1</a><p></p> | <a class="rss" href="https://sethome2.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">
              背包DP问题+动态规划 保姆级教程 包教包会
            </h2>
            <div class="post-date">
              2022-03-25
            </div>
            
                <div class="post-content" v-pre>
                  <p>嘶，突然想起来，高中的时候其实没有认真学过DP（动态规划）的，记忆化搜索和DP只能说是异曲同工之妙，真正的DP核心在于状态转移方程。</p>
<p>之前遇到DP问题，都是直接恩算，尝试找出二维网格里面的一些关系。今天想了想，是应该从背包DP——这最简单的DP开始，一点一点理解动态规划了。</p>
<p><strong>动态规划是一种通过把原问题分解为更简单的子问题，求解子问题来解决复杂问题的方法</strong></p>
<p>长期更新~人菜瘾大。</p>
<h1 id="什么是背包dp">什么是背包DP？</h1>
<p>背包问题简洁的表述就是</p>
<blockquote>
<p>有N个物品，第i个物品的价值为V<sub>i</sub>，同时它的重量为W<sub>i</sub>，有一个背包能装总重为M的物品，<br>
如何取物品，才能使背包内所有物品的价值最大？</p>
</blockquote>
<p><strong>背包DP可以被分为以下几个类型</strong></p>
<table>
<thead>
<tr>
<th>背包类型</th>
<th>特殊条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>01背包</td>
<td>每个物品只能被拿取一次</td>
</tr>
<tr>
<td>完全背包</td>
<td>每个物品物品都可以被重复拿取</td>
</tr>
<tr>
<td>多重背包</td>
<td>现在有两个以上的独立背包用于拿取了</td>
</tr>
<tr>
<td>混合背包</td>
<td>上面三种的混合，物品可以被拿(1, k, ∞)次，同时又有两个以上的背包</td>
</tr>
</tbody>
</table>
<h1 id="01背包问题">01背包问题</h1>
<p>先讲01背包。<br>
参考题目：<a href="https://www.luogu.com.cn/problem/P2871">P2871 [USACO07DEC]Charm Bracelet S</a></p>
<blockquote>
<p>有N个物品，第i个物品的价值为V<sub>i</sub>，同时它的重量为W<sub>i</sub>且只能取一次，<br>
有一个背包能装总重为M的物品，如何取物品，才能使背包内所有物品的价值最大？</p>
</blockquote>
<p>不难想出，我们可以试试每个物品拿或者不拿，可能的组合非常大，为时间复杂度为O(2<sub>N</sub>)。<br>
哪怕如果遇到超过背包装不下的状态而跳过，也是不能接受的复杂度。</p>
<p>先把问题简化一下吧，考虑在三个物品的情况下，背包问题如何解决。</p>
<p>构造一下数据<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，假设我们的背包能装总重量4的物品（M=4）。</p>
<table>
<thead>
<tr>
<th>物品序号N<sub>i</sub></th>
<th>重量W<sub>i</sub></th>
<th>价值V<sub>i</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>15</td>
</tr>
<tr>
<td>1</td>
<td>3</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>30</td>
</tr>
</tbody>
</table>
<p>肉眼观察法，一眼定真，很明显拿取 物品0 和 物品1 是最优的选择。<br>
但是，如何求解呢？</p>
<p>某种程度上我们可以求性价比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub><mo>=</mo><mfrac><msub><mi>V</mi><mi>i</mi></msub><msub><mi>W</mi><mi>i</mi></msub></mfrac></mrow><annotation encoding="application/x-tex">P_i=\frac{V_i}{W_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3335309999999998em;vertical-align:-0.44509999999999994em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8884309999999999em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">W</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.13889em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.22222em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.44509999999999994em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>，,他完美符合我们上述的数据，可我们很容易就举出一个反例。<br>
假设背包能装总重为10的物品。</p>
<table>
<thead>
<tr>
<th>物品序号N<sub>i</sub></th>
<th>重量W<sub>i</sub></th>
<th>价值V<sub>i</sub></th>
<th>性价比P<sub>i</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>7</td>
<td>14</td>
<td>2</td>
</tr>
<tr>
<td>1</td>
<td>6</td>
<td>11</td>
<td>1.83</td>
</tr>
<tr>
<td>2</td>
<td>4</td>
<td>7</td>
<td>1.75</td>
</tr>
</tbody>
</table>
<p>如果按性价比贪心（只拿最高性价比的）就不能比拿取物品1和2的拥有更高价值，也就不能用于处理背包问题。某种意义上可以帮助简化搜索的过程，但是搜索不是正解（记忆化搜索除外，但也属于一种DP）。</p>
<p>回到最初的哪个例子，我们把问题再次简化一下，<strong>将问题分解为情况更小更简单的子问题</strong>。如果我们有能装总重量为M的背包，考虑容量更小的背包，以及更少的物品的情况下呢。</p>
<p>根据上面的假设，我们可以列出这样的一个表格，我们把问题拆分为 <strong>只拿前i个物品</strong> 和 <strong>更小的背包</strong> 的情况。</p>
<table>
<thead>
<tr>
<th></th>
<th>背包容量为0</th>
<th>背包容量为1</th>
<th>背包容量为2</th>
<th>背包容量为3</th>
<th>背包容量为4</th>
</tr>
</thead>
<tbody>
<tr>
<td>只拿前1个物品</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>只拿前2个物品</td>
<td>0</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
<tr>
<td>只拿前3个物品</td>
<td>0</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
</tr>
</tbody>
</table>
<p>不难理解，如果只拿前1个（包括第1个，后面也是）物品，<strong>我们在背包能装得下的情况下（第一行可能不全是物品一的价值）</strong>，就是最优解。这个子问题，解决。</p>
<p>那么只拿前2个呢？现在我们尝试通过子问题来求解新的问题。<br>
我们可以知道分别在背包为0-4的重量时，只考虑拿物品0的最优解。对于我们的只拿前2个的情况，<strong>就是考虑在拿1个的基础上，拿或不拿物品1</strong>。<br>
我们假设当前背包容量为M<sub>i</sub>，以下为重点。</p>
<ul>
<li>拿取了物品1 ：总价值 = 物品0在背包容量为(M<sub>i</sub>减物品1的重量)的价值 + N<sub>1</sub>的价值</li>
<li>放弃物品1 : 总价值 = 物品0在背包容量为M<sub>i</sub>的价值</li>
</ul>
<blockquote>
<p>为什么拿取物品0时，背包容量是原容量减去物品1的重量？<br>
因为拿取物品0时，背包空间就相当于少了物品1的重量，自然要去找子问题的最优解，也就是物品0在此背包容量大小的最大值</p>
<p>假如物品装不下怎么办？<br>
不拿。</p>
</blockquote>
<p>选取 <strong>拿取与放弃物品1的总价值</strong> 中最大的值，我们就可以知道在背包容量为M<sub>i</sub>的情况下的最优解。</p>
<table>
<thead>
<tr>
<th></th>
<th>背包容量为0</th>
<th>背包容量为1</th>
<th>背包容量为2</th>
<th>背包容量为3</th>
<th>背包容量为4</th>
</tr>
</thead>
<tbody>
<tr>
<td>只拿前1个物品</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td></td>
</tr>
<tr>
<td>只拿前2个物品</td>
<td>15</td>
<td>15</td>
<td>20</td>
<td>20</td>
<td></td>
</tr>
<tr>
<td>只拿前3个物品</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td>?</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>以背包容量为3的情况举例，物品1价值20，重量3。</p>
<ul>
<li>拿取物品1的总价值 = 物品0在背包容量为0的价值 + 物品1价值 = 20</li>
<li>放弃物品1的总价值 = 物品0在背包容量为3的价值 = 15<br>
所以应拿取物品1，总价值为20</li>
</ul>
</blockquote>
<p>是不是有点思路了？类似数学归纳法，我们可以发现，只拿前3个物品的情况下，也就是只拿前2个物品的情况下，考虑拿或不拿物品2的总价值，谁更高。<br>
在前三个物品且背包容量为4的状态下就是我们需要的解。</p>
<p>接下来我们用符号来解释，刚才我们的表就是DP数组，假设选取i为序号≧i的物品，j就是当前背包的容量。<br>
物品序号从0开始哦。<br>
W<sub>i</sub>为序号i的物品重量，V<sub>i</sub>为序号i的物品价值。</p>
<strong>
DP[i][j] = max(不拿N~i~的总价值, 拿取N~i~的总价值)
<p>DP[i][j] = max(DP[i - 1][j],  DP[i - 1][j - W<sub>i</sub>] + V<sub>i</sub>)<br>
</strong></p>
<blockquote>
<p>不能理解的可以去看看前面通过子问题计算某个状态的最大值。使用了符号来表达而已。</p>
</blockquote>
<p>最终得到的结果如下，结果就是右下角的DP[2][5] = 35，即为背包的最大价值。</p>
<table>
<thead>
<tr>
<th></th>
<th>j = 0</th>
<th>j = 1</th>
<th>j = 2</th>
<th>j = 3</th>
<th>j = 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>i = 0</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>i = 1</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>20</td>
<td>20</td>
</tr>
<tr>
<td>i = 2</td>
<td>0</td>
<td>15</td>
<td>15</td>
<td>30</td>
<td>35</td>
</tr>
</tbody>
</table>
<p>现在我们可以尝试解上文题目了<br>
参考题目：<a href="https://www.luogu.com.cn/problem/P2871">P2871 [USACO07DEC]Charm Bracelet S</a></p>
<pre><code class="language-C++">#include &quot;iostream&quot;
#include &quot;cmath&quot;
using namespace std;

int DP[3402][99999] = {0}; // 数组DP
int N = 0, M = 0;		   // 物品数量与背包容量

int N_W[3500] = {0}; // 物品重量
int N_V[3500] = {0}; // 物品价值

int main()
{
	cin &gt;&gt; N &gt;&gt; M; // 读取数据
	for (int i = 0; i &lt; N; i++)
		cin &gt;&gt; N_W[i] &gt;&gt; N_V[i];

	for (int i = 0; i &lt;= M; i++) // 初始化第一个物品的情况
		if (i &gt;= N_W[0])
			DP[0][i] = N_V[0];

	for (int i = 1; i &lt; N; i++) // DP循环
		for (int j = 1; j &lt;= M; j++)
			if (j &gt;= N_W[i])												  // 背包容量要大于物品容量才能拿取
				DP[i][j] = max(DP[i - 1][j], DP[i - 1][j - N_W[i]] + N_V[i]); // 比较拿取与不拿取谁更大
			else
				DP[i][j] = DP[i - 1][j];

	cout &lt;&lt; DP[N - 1][M]; // 输出结果
	return 0;
}
</code></pre>
<p>__ HOLD SHIT, MLE(Memory Limit Exceed)! 二维数组需要的数据量还是太大了__，导致了内存过大，要AC这个题，我们需要接近2GB的内存容量(逃</p>
<h2 id="优化dp数组">优化DP数组</h2>
<p>分析代码，可以发现DP数组是导致内存膨胀的主要原因。<br>
还是以刚才的DP数组为例，我们发现，当我们更新i = 2这一列的时候，i = 1以前的数据是完全不需要的。<br>
也就是说，前 i - 2 的物品数据是完全不会被使用到的，这样我们就可以用一维数组存储数据了。</p>
<table>
<thead>
<tr>
<th>j = 0</th>
<th>j = 1</th>
<th>j = 2</th>
<th>j = 3</th>
<th>j = 4</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>15</td>
<td>15</td>
<td>30</td>
<td>35</td>
</tr>
</tbody>
</table>
<p>同时我们再对背包容量的循环做些优化，可以得到以下代码。</p>
<pre><code class="language-C++">#include &quot;iostream&quot;
#include &quot;cmath&quot;
using namespace std;

int DP[12882] = {0}; // 数组DP
int N = 0, M = 0;	 // 物品数量与背包容量

int N_W[3500] = {0}; // 物品重量
int N_V[3500] = {0}; // 物品价值

int main()
{
	cin &gt;&gt; N &gt;&gt; M; // 读取数据
	for (int i = 0; i &lt; N; i++)
		cin &gt;&gt; N_W[i] &gt;&gt; N_V[i];

	for (int i = 0; i &lt; N; i++) // DP循环
		for (int j = M; j &gt;= N_W[i]; j--)
			DP[j] = max(DP[j], DP[j - N_W[i]] + N_V[i]);

	cout &lt;&lt; DP[M]; // 输出结果

	return 0;
}
</code></pre>
<blockquote>
<p>注：此时第二个for的遍历顺序必须从大往小，因为在二维DP数组中，我们拿取第i个物品时，DP[i - 1][j]是不会被更新的。<br>
但是在一维数组下，物品i在被拿取后，DP[j]就被立即更新，在后续随着j的更新，max(DP[j], DP[j - N_W[i]] + N_V[i])会取到之前被更新的值，也就可以被重复拿取了。<br>
<strong>事实上，调换更新顺序就是完全背包问题的解法</strong></p>
</blockquote>
<h1 id="完全背包问题">完全背包问题</h1>
<p>仔细阅读01背包问题的一维解法，你会发现，交换第二层for的顺序就可以完成了。提供代码如下。<br>
这里就不啰嗦了（其实是不知道怎么在md里面链接自己的段落）。</p>
<pre><code class="language-C++">#include &quot;iostream&quot;
#include &quot;cmath&quot;
using namespace std;

int DP[12882] = {0}; // 数组DP
int N = 0, M = 0;	 // 物品数量与背包容量

int N_W[3500] = {0}; // 物品重量
int N_V[3500] = {0}; // 物品价值

int main()
{
	cin &gt;&gt; N &gt;&gt; M; // 读取数据
	for (int i = 0; i &lt; N; i++)
		cin &gt;&gt; N_W[i] &gt;&gt; N_V[i];

	for (int i = 0; i &lt; N; i++) // DP循环
		for (int j = M; j &gt;= N_W[i]; j--)
			DP[j] = max(DP[j], DP[j - N_W[i]] + N_V[i]);

	cout &lt;&lt; DP[M]; // 输出结果

	return 0;
}
</code></pre>
<h1 id="在重新理解一次理解dp有点对不起这个标题">在重新理解一次理解DP（有点对不起这个标题</h1>
<p>DP(Dynamic programming)，动态规划。（我并不认为它的名字和思想有什么关联）</p>
<blockquote>
<p><strong>动态规划是一种通过把原问题分解为更简单的子问题，求解子问题来解决复杂问题的方法</strong></p>
</blockquote>
<p>通常我们解题的过程如下：</p>
<ol>
<li>我们在尝试解决背包问题的时候，最先开始制定了一种可能的规则，把原问题分解为不同的子问题。</li>
<li>尝试寻找从i - 1状态（或者更前的状态），更新到当前i状态的规则与方程。（也叫 <strong>动态转移方程</strong> ）</li>
<li>确定状态的 <strong>边界</strong>（前面的解释中我们提前了一步）</li>
<li>根据动态转移方程，得出最终的答案</li>
</ol>
<p>一步一步来解释吧。<br>
在第一步中，我们将问题分解的过程中需要考虑__最优子结构__ 和 <strong>无后效性</strong>  以及  <strong>子问题的重叠性</strong>。</p>
<blockquote>
<p>最优子结构：原问题的最优解所包含的子问题的解也能得到最优解<br>
无后效性：子问题的最优解一旦确定，就不再改变。（即使后面有更大更复杂的问题）<br>
子问题的重叠性: 在使用模拟或者递归求解时，总是会重复的求解某些子问题</p>
<p>如果我们构造的子问题有任一不满足，则很可能不能使用DP思想。</p>
</blockquote>
<p>在我们成功构造子问题后，需要查找子问题与原问题的关系规则，也就是 <strong>动态转移方程</strong>。这个也是DP最难的问题，在下也没用很好的技巧帮助你。<br>
个人解题习惯会展开子问题与原问题的解（类似我们构造二维DP数组），构造部分数据手算答案，再寻找可能的关系与规则。</p>
<p>接下来是 <strong>边界</strong>，其实就是动态转移中的第一个状态。<br>
一个问题总不能有无限的子问题，至少在求解的时候不能，这就需要我们自己构造合理的数据填入，然后再开始进行动态转移。在背包DP的例子中，我们的边界就是背包容量为0和前一个物品的时候。</p>
<p>最后还是要啰嗦的是，一个问题满足以下条件后，才可能使用DP思想解决，<strong>最优子结构</strong> 和 <strong>无后效性</strong>  以及  <strong>子问题的重叠性</strong>。</p>
<hr>
<p>终于写完啦，写了5h，希望还能对你有所帮助。如果可以的话还请收藏我的blog哦。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>这里参考了<a href="https://zhuanlan.zhihu.com/p/345364527">这篇文章</a>的数据，感谢作者的付出。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>

                </div>
                
                  <div class="tag-container">
                    
                      <a href="https://sethome2.github.io/tag/AxMbzInct/" class="tag">
                        algorithm
                      </a>
                      
                      <a href="https://sethome2.github.io/tag/DPgomazXOf/" class="tag">
                        technique
                      </a>
                      
                      <a href="https://sethome2.github.io/tag/orC5ANx2z/" class="tag">
                        中文
                      </a>
                      
                  </div>
                  
                    
                      <div class="next-post">
                        <div class="next">下一篇</div>
                        <a href="https://sethome2.github.io/post/pian-fen-dao-lun/">
                          <h3 class="post-title">
                            骗分导论
                          </h3>
                        </a>
                      </div>
                      

                        
                          
                            <div id="gitalk-container" data-aos="fade-in"></div>
                            

                              
                                  

          </div>

        </div>
      </div>
  </div>

  <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>




  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'a66037dc805d2519c1e3',
        clientSecret: '77cbde8229074e52566ea21d48e65a0e3f4e542c',
        repo: 'comment-website',
        owner: 'sethome2',
        admin: ['sethome2'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




</body>

</html>